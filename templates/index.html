<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Batman Steam Analyzer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background-color: #0a0a0a;
        color: #e0e0e0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Header Bar */
      .header {
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        background-color: #000;
      }

      /* Version and Timezone Container */
      .version-container {
        text-align: right;
      }

      /* Version Label */
      .version-label {
        color: white;
        font-size: 14px;
        font-weight: 500;
      }

      /* Timezone Label */
      .timezone-label {
        color: #999;
        font-size: 11px;
        font-weight: 400;
        margin-top: 2px;
      }

      /* Batman Logo */
      .batman-logo {
        width: 48px;
        height: 48px;
        position: relative;
        flex-shrink: 0;
      }

      .batman-logo svg {
        width: 100%;
        height: 100%;
        fill: #ffd700;
      }

      .batman-logo svg ellipse {
        transition: fill 0.3s ease;
      }

      .batman-logo svg path {
        transition: fill 0.3s ease;
      }

      .batman-logo svg rect {
        transition: fill 0.3s ease;
      }

      .batman-logo:hover svg ellipse {
        fill: #ffffff;
      }

      .batman-logo:hover svg path {
        fill: #ff0000;
      }

      .batman-logo:hover svg rect {
        fill: #ff0000;
      }

      /* Input Section */
      .input-section {
        padding: 20px;
        background-color: #000;
      }

      .input-container {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        gap: 20px;
        align-items: flex-start;
      }

      .url-input-wrapper {
        flex: 0 0 35%;
      }
      .search-terms-wrapper {
        flex: 0 0 45%;
        /* padding-left: 20px; */
        display: flex;
      }

      .crawl-output-wrapper {
        flex: 0 0 20%;
        padding-left: 20px;
        text-align: left;
      }

      .crawl-output {
        background-color: #111;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 12px;
        min-height: 120px;
        color: #e0e0e0;
        font-size: 11px;
        line-height: 1.6;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        display: none;
      }

      .crawl-output.show {
        display: block;
        opacity: 1;
      }

      .crawl-output-header {
        color: #ffd700;
        font-weight: 600;
        margin-bottom: 8px;
        font-size: 12px;
      }

      .crawl-stat-line {
        margin-bottom: 6px;
      }

      .url-input-wrapper label {
        display: block;
        margin-bottom: 8px;
        color: #999;
        font-size: 14px;
      }

      .url-textarea {
        width: 100%;
        background-color: transparent;
        border: none;
        border-bottom: 1px solid #333;
        color: #e0e0e0;
        padding: 0;
        height: 18vh;
        font-family: monospace;
        font-size: 14px;
        resize: none;
        transition: border-bottom-color 0.1s ease-in-out;
      }

      .url-textarea:focus {
        outline: none;
        border-bottom-color: #a0a0a0;
      }

      /* Timer Styles */
      .crawl-timer {
        color: #ffd700;
        font-family: inherit; /* Use same font as parent h2 */
        font-size: 0.9em; /* Much smaller than h2 (1.5em) */
        font-weight: inherit; /* Use same weight as parent h2 */
        margin-left: 15px;
        margin-bottom: 16px; /* Match h2 bottom margin */
        display: none;
        align-items: baseline; /* Align baselines */
      }

      .crawl-timer.show {
        display: flex;
      }

      .crawl-status {
        color: #ff6b6b;
        margin-left: 10px;
        margin-bottom: 16px; /* Match timer bottom margin */
        font-weight: normal;
        font-size: 0.9em; /* Match timer font size */
        display: none;
        align-items: baseline; /* Match timer baseline alignment */
      }

      .crawl-status.show {
        display: inline;
      }

      .crawler-header {
        display: flex;
        align-items: center;
      }

      .summary-content {
        max-width: 1200px;
        margin: 0 auto;
      }

      .summary-stats {
        font-size: 12px;
        line-height: 1.4;
        color: #e0e0e0;
      }

      .summary-text {
        color: #999;
      }

      .summary-label {
        color: #999;
      }

      .summary-value {
        color: #ffd700;
        font-weight: 600;
      }

      /* Analysis Section */
      .analysis-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background-color: #000;
      }

      /* Tabs */
      .tabs-container {
        padding: 0 20px;
        border-bottom: 1px solid rgba(255, 215, 0, 0.1);
      }

      .tabs {
        display: flex;
        gap: 2px;
        max-width: 1200px;
        margin: 0 auto;
      }

      .tab {
        background-color: transparent;
        color: #666;
        border: none;
        padding: 16px 24px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
        position: relative;
      }

      .tab:hover {
        color: #999;
      }

      .tab.active {
        color: #ffd700;
      }

      /* Tab Content */
      .tab-content {
        flex: 1;
        display: none;
        padding: 20px;
        overflow: auto;
      }

      .tab-content.active {
        display: block;
      }

      .content-wrapper {
        max-width: 1200px;
        margin: 0 auto;
      }

      /* Search Controls */
      .search-controls {
        padding: 16px 0;
        margin-bottom: 15px;
        display: grid;
        grid-template-columns: 1fr auto auto auto;
        gap: 16px;
        align-items: center;
        min-height: 48px;
      }

      .search-input {
        min-width: 300px;
        background-color: transparent;
        border: none;
        border-bottom: 1px solid #333;
        color: #e0e0e0;
        padding: 10px 0;
        font-size: 14px;
      }

      /* Tab-specific search input widths - 50% of container */
      #flagged-comments .search-input,
      #villains .search-input,
      #further-monitoring .search-input,
      #reported-profiles .search-input,
      #unprocessed-profiles .search-input {
        width: 50%;
        min-width: 200px;
      }

      .search-input {
        transition: border-bottom-color 0.1s ease-in-out;
      }

      .search-input:focus {
        outline: none;
        border-bottom-color: #a0a0a0;
      }

      .filter-select {
        background-color: transparent;
        border: none;
        border-bottom: 1px solid #333;
        color: #e0e0e0;
        padding: 10px 0;
        font-size: 14px;
        cursor: pointer;
        transition: border-bottom-color 0.1s ease-in-out;
      }

      .filter-select:focus {
        outline: none;
        border-bottom-color: #a0a0a0;
      }

      .search-button {
        background-color: transparent;
        color: white;
        border: none;
        padding: 16px 32px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
        position: relative;
      }

      .search-button:hover {
        color: #ffd700;
        transform: translateY(-2px);
      }

      /* Tab-specific search control layouts */
      #flagged-comments .search-controls {
        grid-template-columns: 40px 250px 1fr 120px 120px 130px;
        align-items: center;
        gap: 8px;
      }

      #flagged-comments .search-controls .steamid-search {
        grid-column: 2;
        width: 100%;
      }

      #flagged-comments .search-controls .comment-search {
        grid-column: 3;
        width: 100%;
      }

      #flagged-comments .search-controls .filter-select:first-of-type {
        grid-column: 4;
        justify-self: stretch;
        width: 100%;
      }

      #flagged-comments .search-controls .filter-select:last-of-type {
        grid-column: 5;
        justify-self: stretch;
        width: 100%;
      }

      #villains .search-controls {
        grid-template-columns: 40px 250px 1fr 120px 130px;
        align-items: center;
        gap: 8px;
      }

      #villains .search-controls .search-input {
        grid-column: 2 / 4;
        width: 100%;
      }

      #villains .search-controls .filter-select:first-of-type {
        grid-column: 4;
        justify-self: stretch;
        width: 100%;
      }

      #villains .search-controls .filter-select:last-of-type {
        grid-column: 5;
        justify-self: stretch;
        width: 100%;
      }

      #further-monitoring .search-controls {
        grid-template-columns: 40px 250px 1fr 120px 130px;
        align-items: center;
        gap: 8px;
      }

      #further-monitoring .search-controls .search-input {
        grid-column: 2 / 4;
        width: 100%;
      }

      #further-monitoring .search-controls .filter-select {
        grid-column: 4;
        justify-self: stretch;
        width: 100%;
      }

      #unprocessed-profiles .search-controls {
        grid-template-columns: 250px 1fr 120px 120px;
        align-items: center;
        gap: 8px;
      }

      #unprocessed-profiles .search-controls .search-input {
        grid-column: 1 / 3;
        width: 100%;
      }

      #unprocessed-profiles .search-controls .filter-select {
        grid-column: 3;
        justify-self: stretch;
        width: 100%;
      }

      /* Ensure consistent timestamp sizing across all tabs */
      #unprocessed-profiles .timestamp {
        font-size: 13px;
      }

      #reported-profiles .search-controls {
        grid-template-columns: 40px 250px 1fr 120px 120px 130px;
        align-items: center;
        gap: 8px;
      }

      #reported-profiles .search-controls .search-input {
        grid-column: 2 / 4;
        width: 100%;
      }

      #reported-profiles .search-controls .filter-select:first-of-type {
        grid-column: 4;
        justify-self: stretch;
        width: 100%;
      }

      #reported-profiles .search-controls .filter-select:last-of-type {
        grid-column: 5;
        justify-self: stretch;
        width: 100%;
      }

      /* Results Table */
      .results-table {
        margin-top: 20px;
      }

      .table-header {
        padding: 16px 0;
        font-weight: 600;
        display: grid;
        gap: 8px;
        border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        color: #ffffff;
      }

      .flagged-comments-header {
        grid-template-columns: 40px 250px 1fr 120px 120px 130px;
      }

      .flagged-comments-header > div:nth-child(4),
      .reported-profiles-header > div:nth-child(4) {
        color: #ffffff;
      }

      .villains-header {
        grid-template-columns: 40px 250px 1fr 120px 130px;
      }

      .reported-profiles-header {
        grid-template-columns: 40px 250px 1fr 120px 120px 130px;
      }

      .table-row {
        padding: 16px 0;
        display: grid;
        gap: 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        align-items: center;
        position: relative;
      }

      .flagged-comments-row {
        grid-template-columns: 40px 250px 1fr 120px 120px 130px;
      }

      .villains-row {
        grid-template-columns: 40px 250px 1fr 120px 130px;
      }

      .reported-profiles-row {
        grid-template-columns: 40px 250px 1fr 120px 120px 130px;
      }

      /* Smooth row hover animations */
      .table-row > div:nth-child(2),
      .table-row > div:nth-child(3),
      .table-row > div:nth-child(2) small {
        transition: all 0.4s cubic-bezier(0.1, 0.9, 0.2, 1);
      }

      .table-row.hover-monitor > div:nth-child(2) {
        color: #ffd700;
        transform: translateX(8px);
      }

      .table-row.hover-report > div:nth-child(2) small {
        color: #ff4444 !important;
        transform: translateX(8px);
      }

      /* Reported profiles tab specific hover effects */
      #reported-profiles .table-row.hover-monitor > div:nth-child(2) {
        color: #ffd700;
        transform: translateX(8px);
      }

      #reported-profiles .table-row.hover-report > div:nth-child(2) small {
        color: #4caf50 !important;
        transform: translateX(8px);
      }

      #reported-profiles .table-row.hover-confirm > div:nth-child(2) small {
        color: #4caf50 !important;
        transform: translateX(8px);
      }

      .comment-text {
        color: #ffd700;
        line-height: 1.4;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
        max-width: 100%;
        white-space: pre-wrap;
      }

      .timestamp {
        color: #666;
        font-size: 13px;
        display: flex;
        flex-direction: column;
        gap: 2px;
        line-height: 1.2;
        align-items: flex-start;
      }

      .status-badge {
        color: #666;
        font-size: 13px;
      }

      .status-badge.pending {
        color: #ff9800;
      }

      .status-badge.submitted {
        color: #4caf50;
      }

      /* Status colors for report center */
      .status-badge.pending-manual-review {
        color: #cc0000;
      }

      .status-badge.pending-review {
        color: #cc0000;
      }

      .status-badge.reported {
        color: #00cc00;
      }

      .actions {
        display: flex;
        gap: 12px;
        justify-content: flex-start;
      }

      /* Action Buttons */
      .action-button {
        width: 32px;
        height: 32px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        background-color: transparent;
        position: relative;
      }

      .action-button:hover {
        transform: translateY(-1px);
      }

      .report-button {
        background-color: rgba(255, 68, 68, 0.1);
        border: 1px solid rgba(255, 68, 68, 0.3);
      }

      .report-button:hover {
        background-color: #ff4444;
        border-color: #ff4444;
        box-shadow: 0 2px 8px rgba(255, 68, 68, 0.3);
      }

      .monitor-button {
        background-color: rgba(102, 102, 102, 0.1);
        border: 1px solid rgba(102, 102, 102, 0.3);
      }

      .monitor-button:hover {
        background-color: #666;
        border-color: #666;
        box-shadow: 0 2px 8px rgba(102, 102, 102, 0.3);
      }

      /* Icons */
      .icon {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      .report-button .icon {
        color: #ff4444;
      }

      .report-button:hover .icon {
        color: #fff;
      }

      .monitor-button .icon {
        color: #666;
        transition: all 0.3s ease;
      }

      .monitor-button:hover .icon {
        color: #fff;
      }

      /* Eye animation styles */
      .eye-closed {
        display: block;
      }

      .eye-open {
        display: none;
      }

      .monitor-button:hover .eye-closed {
        display: none;
      }

      .monitor-button:hover .eye-open {
        display: block;
      }

      .confirm-button {
        background-color: rgba(76, 175, 80, 0.1);
        border: 1px solid rgba(76, 175, 80, 0.3);
      }

      .confirm-button:hover {
        background-color: #4caf50;
        border-color: #4caf50;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
      }

      .confirm-button .icon {
        color: #4caf50;
      }

      .confirm-button:hover .icon {
        color: #fff;
      }

      .remove-button {
        background-color: rgba(180, 50, 50, 0.2);
        border: 1px solid rgba(180, 50, 50, 0.5);
      }

      .remove-button:hover {
        background-color: #b43232;
        border-color: #b43232;
        box-shadow: 0 2px 8px rgba(180, 50, 50, 0.4);
      }

      .remove-button .icon {
        color: #b43232;
      }

      .remove-button:hover .icon {
        color: #fff;
      }

      .edit-button {
        background-color: rgba(255, 215, 0, 0.1);
        border: 1px solid rgba(255, 215, 0, 0.3);
      }

      .edit-button:hover {
        background-color: #ffd700;
        border-color: #ffd700;
        box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
      }

      .edit-button .icon {
        color: #ffd700;
      }

      .edit-button:hover .icon {
        color: #000;
      }

      /* Modal styles for user notes editing */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
      }

      .modal-content {
        background-color: #1a1a1a;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #333;
        border-radius: 8px;
        width: 500px;
        max-width: 90%;
      }

      .modal-header {
        color: #ffd700;
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 16px;
      }

      .modal-textarea {
        width: 100%;
        min-height: 120px;
        background-color: #0a0a0a;
        border: 1px solid #333;
        border-radius: 4px;
        color: #e0e0e0;
        padding: 12px;
        font-family: inherit;
        font-size: 14px;
        margin-bottom: 16px;
      }

      .modal-textarea:focus {
        outline: none;
        border-color: #ffd700;
      }

      .modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .modal-button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.2s ease;
      }

      .modal-button.save {
        background-color: #ffd700;
        color: #000;
      }

      .modal-button.save:hover {
        background-color: #ffed4e;
      }

      .modal-button.cancel {
        background-color: #333;
        color: #e0e0e0;
      }

      .modal-button.cancel:hover {
        background-color: #444;
      }

      /* Empty State */
      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: #666;
      }

      .empty-state h3 {
        font-size: 20px;
        margin-bottom: 8px;
        color: #999;
      }

      /* Column-specific text sizes */
      .table-row > div:first-child {
        font-size: 12px;
      }

      .table-row > div:nth-child(2) {
        font-size: 12px;
      }

      .table-row > div:nth-child(3) {
        font-size: 12px;
      }

      .table-row > div:nth-child(4) {
        font-size: 14px;
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }

      ::-webkit-scrollbar-track {
        background: transparent;
      }

      ::-webkit-scrollbar-thumb {
        background: #333;
        border-radius: 3px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #444;
      }

      /* Steam ID hover and click styles */
      .steam-id {
        cursor: pointer;
        transition: color 0.2s ease;
      }

      .steam-id:hover {
        color: #9c27b0;
      }

      /* Avatar styles */
      .avatar-cell {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .steam-avatar {
        width: 32px;
        height: 32px;
        border-radius: 4px;
        object-fit: cover;
      }

      .steam-avatar-placeholder {
        width: 32px;
        height: 32px;
        border-radius: 4px;
        background-color: #333;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: #666;
      }

      /* User Notes column styling */
      .user-notes {
        color: #ffd700;
        transition: all 0.4s cubic-bezier(0.1, 0.9, 0.2, 1);
        white-space: pre-wrap;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
        line-height: 1.4;
        max-height: 120px;
        overflow-y: auto;
      }

      .table-header .user-notes-header {
        color: #ffffff;
      }

      /* Edit button hover effect on user notes */
      .table-row.hover-edit .user-notes {
        color: #ffd700;
        transform: translateX(8px) scale(1.05);
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
      }

      /* Search terms container */
      .search-terms-list {
        max-height: calc(100vh - 380px);
        overflow-y: auto;
        border: 1px solid #333333;
        background-color: transparent;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
      }

      /* Hide scrollbar for WebKit browsers */
      .search-terms-list::-webkit-scrollbar {
        display: none;
      }

      /* Borderless variant for inline search terms */
      .search-terms-list.borderless {
        border: none;
        background-color: transparent;
        height: 200px;
        max-height: 200px;
        overflow-y: auto;
      }

      .search-terms-list:focus-within {
        border-color: #ffd700;
      }

      /* Smaller delete buttons specifically for search terms lists */
      .search-terms-list .remove-button {
        width: 20px;
        height: 20px;
      }

      .search-terms-list .remove-button .icon {
        width: 12px;
        height: 12px;
      }

      /* Search term hover highlighting - specific transitions only */

      .search-term-item:has(.remove-button:hover) .search-term-text {
        color: #ff6b6b !important;
        background-color: rgba(255, 107, 107, 0.1);
        padding: 2px 4px;
        border-radius: 3px;
      }

      /* Prevent action button transitions from affecting search term buttons */
      .search-terms-list .action-button {
        transition: background-color 0.2s ease, border-color 0.2s ease,
          box-shadow 0.2s ease !important;
        transform: none !important;
      }

      /* Re-enable only the specific transitions we want for search term buttons */
      .search-terms-list .action-button:hover {
        transform: none !important;
      }

      /* Ensure search term text only animates when its own button is hovered */
      .search-term-item .search-term-text {
        transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
          background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
          padding 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
    </style>
  </head>
  <body>
    <!-- Header Bar -->
    <header class="header">
      <div class="batman-logo">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 186">
          <!-- Yellow oval background (optional - remove if you just want the bat) -->
          <ellipse cx="150" cy="93" ry="88" rx="145" fill="#FFD700" />

          <!-- Batman symbol -->
          <g>
            <!-- Left half of bat -->
            <path
              fill="#000000"
              d="M150,30 L140,30 L132,19 C134,100 67,83 102,20 C0,70 0,100 70,156 C38,125 81,105 107,145 C115,127.6 140,127.6 149.5,169 L150,30 z"
            />

            <!-- Right half of bat (flipped) -->
            <path
              fill="#000000"
              d="M150,30 L160,30 L168,19 C166,100 233,83 198,20 C300,70 300,100 230,156 C262,125 219,105 193,145 C185,127.6 160,127.6 150.5,169 L150,30 z"
            />

            <!-- Center fill to cover yellow gap -->
            <rect x="149.5" y="30" width="1" height="139" fill="#000000" />
          </g>
        </svg>
      </div>
      <div class="version-container">
        <div class="version-label">v1.1</div>
        <div class="timezone-label">All times in EDT</div>
      </div>
    </header>

    <!-- Input Section -->
    <section class="input-section">
      <div class="input-container">
        <div class="url-input-wrapper">
          <div class="crawler-header">
            <h2 style="color: #ffd700; margin: 0 0 16px 0">Crawler</h2>
            <div class="crawl-timer" id="crawl-timer">00:00:00</div>
            <span class="crawl-status" id="crawl-status"></span>
          </div>
          <textarea
            id="url-input"
            class="url-textarea"
            placeholder=""
          ></textarea>
        </div>
        <div class="search-terms-wrapper">
          <div style="display: flex; gap: 20px; height: 100%">
            <!-- Left side: Controls (75%) -->
            <div style="flex: 0 0 75%; display: flex; flex-direction: column">
              <h2 style="color: #ffd700; margin: 0 0 74px 0">
                Search Terms
                <span
                  id="inline-hate-terms-count"
                  style="color: #666; font-size: 14px; font-weight: normal"
                  >0 terms</span
                >
              </h2>
              <div
                style="
                  display: flex;
                  gap: 10px;
                  margin-bottom: 16px;
                  align-items: center;
                "
              >
                <input
                  type="text"
                  id="inline-new-hate-term-input"
                  class="search-input"
                  placeholder="Add term..."
                  style="width: 400px"
                />
              </div>
              <div
                style="
                  display: flex;
                  gap: 10px;
                  margin-bottom: 16px;
                  align-items: center;
                "
              >
                <input
                  type="text"
                  id="inline-hate-terms-search"
                  class="search-input"
                  placeholder="Search terms list..."
                  style="width: 400px"
                  onkeyup="filterInlineHateTerms()"
                />
              </div>
            </div>
            <!-- Right side: Search Terms List (40%) -->
            <div style="flex: 0 0 40%">
              <div class="results-table" style="margin-top: 0; height: 100%">
                <div
                  id="inline-hate-terms-results"
                  class="search-terms-list borderless"
                ></div>
              </div>
            </div>
          </div>
        </div>
        <div class="crawl-output-wrapper">
          <div class="crawl-output" id="crawl-output">
            <div class="crawl-output-header">Results</div>
            <div id="crawl-result-content">
              <div class="crawl-stat-line">
                <span class="summary-label">Comments: </span>
                <span class="summary-value" id="new-flagged-comments">0</span>
              </div>
              <div class="crawl-stat-line">
                <span class="summary-label">Unique: </span>
                <span class="summary-value" id="unique-villains">0</span>
              </div>
              <div class="crawl-stat-line">
                <span class="summary-label">New: </span>
                <span class="summary-value" id="new-villains">0</span>
              </div>
              <div class="crawl-stat-line">
                <span class="summary-label">Exit: </span>
                <span class="summary-value" id="exit-reason">Unknown</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Analysis Section -->
    <section class="analysis-section">
      <!-- Header with Tabs -->
      <div class="tabs-container">
        <div
          class="tabs"
          style="
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
          "
        >
          <h2 style="color: #ffd700; margin: 0; position: absolute; left: 0">
            Analysis
          </h2>
          <div style="display: flex; gap: 2px">
            <button class="tab active" data-tab="flagged-comments">
              COMMENTS
            </button>
            <button class="tab" data-tab="villains">VILLAINS</button>
            <button class="tab" data-tab="further-monitoring">
              MONITORING
            </button>
            <button class="tab" data-tab="reported-profiles">
              REPORT CENTER
            </button>
            <button class="tab" data-tab="unprocessed-profiles">
              UNPROCESSED PROFILES
            </button>
          </div>
        </div>
      </div>

      <!-- Tab Contents -->
      <div class="tab-content active" id="flagged-comments">
        <div class="content-wrapper">
          <div class="search-controls">
            <input
              type="text"
              class="search-input steamid-search"
              placeholder="Search by Steam ID or Alias..."
            />
            <input
              type="text"
              class="search-input comment-search"
              placeholder="Search Comments..."
            />
            <select class="filter-select" id="sort-select">
              <option value="newest">Newest</option>
              <option value="oldest">Oldest</option>
            </select>
            <select class="filter-select" id="time-filter-select">
              <option>All Time</option>
              <option>Past 1 Hour</option>
              <option>Past 24 Hours</option>
              <option>Past 7 Days</option>
            </select>
          </div>

          <div class="results-table">
            <div class="table-header flagged-comments-header">
              <div></div>
              <div>
                <div>Steam ID</div>
                <div>& Alias</div>
              </div>
              <div>Comment</div>
              <div>Date Commented</div>
              <div>
                <div>Date</div>
                <div>Added</div>
              </div>
              <div></div>
            </div>
          </div>
        </div>
      </div>

      <div class="tab-content" id="villains">
        <div class="content-wrapper">
          <!-- Manual Add Villain Section -->
          <div
            class="add-villain-section"
            style="padding: 16px 0; margin-bottom: 8px"
          >
            <div
              style="
                display: grid;
                grid-template-columns: 40px 250px 1fr;
                gap: 16px;
                align-items: center;
              "
            >
              <div></div>
              <h2 style="color: #ffd700; margin: 0">Add Villain</h2>
              <input
                type="text"
                id="manual-steam-id-input"
                class="search-input"
                placeholder="Enter a Steam ID or User Alias..."
                style="margin: 0"
                onkeydown="if(event.key === 'Enter') addManualVillain()"
              />
            </div>
          </div>

          <div class="search-controls">
            <input
              type="text"
              id="villains-search-input"
              class="search-input"
              placeholder="Search by Steam ID or Alias..."
            />
            <select class="filter-select" id="villains-sort-select">
              <option value="newest">Newest</option>
              <option value="oldest">Oldest</option>
            </select>
            <select class="filter-select" id="villains-time-filter">
              <option>All Time</option>
              <option>Past 1 Hour</option>
              <option>Past 24 Hours</option>
              <option>Past 7 Days</option>
            </select>
          </div>

          <div class="results-table">
            <div class="table-header villains-header">
              <div></div>
              <div>
                <div>Steam ID</div>
                <div>& Alias</div>
              </div>
              <div class="user-notes-header">
                <div>User</div>
                <div>Notes</div>
              </div>
              <div>
                <div>Date</div>
                <div>Added</div>
              </div>
              <div></div>
            </div>

            <div class="empty-state">
              <h3>No villains found</h3>
              <p>Run a crawl to detect users posting hate speech</p>
            </div>
          </div>
        </div>
      </div>

      <div class="tab-content" id="reported-profiles">
        <div class="content-wrapper">
          <div class="search-controls">
            <input
              type="text"
              class="search-input"
              placeholder="Search by Steam ID or Alias..."
            />
            <select class="filter-select" id="reported-status-filter">
              <option>All Statuses</option>
              <option>Pending Review</option>
              <option>Reported</option>
            </select>
            <select class="filter-select" id="reported-time-filter">
              <option>All Time</option>
              <option>Past 1 Hour</option>
              <option>Past 24 Hours</option>
              <option>Past 7 Days</option>
            </select>
          </div>

          <div class="results-table">
            <div class="table-header reported-profiles-header">
              <div></div>
              <div>
                <div>Steam ID</div>
                <div>& Alias</div>
              </div>
              <div>Comment</div>
              <div>Status</div>
              <div>
                <div>Date</div>
                <div>Added</div>
              </div>
              <div></div>
            </div>

            <div class="empty-state">
              <h3>No reported profiles</h3>
              <p>
                Select comments from the Flagged Comments tab to report profiles
              </p>
            </div>
          </div>
        </div>
      </div>

      <div class="tab-content" id="further-monitoring">
        <div class="content-wrapper">
          <div class="search-controls">
            <input
              type="text"
              class="search-input"
              placeholder="Search by Steam ID or Alias..."
            />
            <select class="filter-select" id="monitoring-time-filter">
              <option>All Time</option>
              <option>Past 1 Hour</option>
              <option>Past 24 Hours</option>
              <option>Past 7 Days</option>
            </select>
          </div>

          <div class="results-table">
            <div class="empty-state">
              <h3>No profiles being monitored</h3>
              <p>
                Add profiles from Comments or Villains tabs for continued
                monitoring
              </p>
            </div>
          </div>
        </div>
      </div>

      <div class="tab-content" id="unprocessed-profiles">
        <div class="content-wrapper">
          <div class="search-controls">
            <input
              type="text"
              class="search-input"
              placeholder="Search by Steam ID or Alias..."
            />
            <select class="filter-select" id="unprocessed-time-filter">
              <option>All Time</option>
              <option>Past 1 Hour</option>
              <option>Past 24 Hours</option>
              <option>Past 7 Days</option>
            </select>
          </div>

          <div class="results-table">
            <div class="empty-state">
              <h3>No unprocessed profiles</h3>
              <p>
                Profiles that couldn't be processed due to system limits will
                appear here
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- User Notes Edit Modal -->
    <div id="userNotesModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">Edit User Notes</div>
        <textarea
          id="userNotesTextarea"
          class="modal-textarea"
          placeholder="Enter notes about this user..."
        ></textarea>
        <div class="modal-buttons">
          <button class="modal-button cancel" onclick="closeUserNotesModal()">
            Cancel
          </button>
          <button class="modal-button save" onclick="saveUserNotes()">
            Save
          </button>
        </div>
      </div>
    </div>

    <script>
      // Test if JavaScript is working at all
      console.log("JavaScript is loading...");

      // API base URL
      const API_BASE = "http://localhost:5001/api";

      // Tab switching functionality
      document.querySelectorAll(".tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          // Remove active class from all tabs and contents
          document
            .querySelectorAll(".tab")
            .forEach((t) => t.classList.remove("active"));
          document
            .querySelectorAll(".tab-content")
            .forEach((c) => c.classList.remove("active"));

          // Add active class to clicked tab and corresponding content
          tab.classList.add("active");
          const tabId = tab.getAttribute("data-tab");
          document.getElementById(tabId).classList.add("active");

          // Load data for the new tab
          setTimeout(loadCurrentTab, 100); // Small delay for tab to become active
        });
      });

      // Timer variables
      let crawlStartTime = null;
      let timerInterval = null;

      // Format time as MM:SS:MS
      function formatTime(milliseconds) {
        const totalMs = Math.floor(milliseconds);
        const minutes = Math.floor(totalMs / 60000);
        const seconds = Math.floor((totalMs % 60000) / 1000);
        const ms = Math.floor((totalMs % 1000) / 10); // Show centiseconds

        return `${minutes.toString().padStart(2, "0")}:${seconds
          .toString()
          .padStart(2, "0")}:${ms.toString().padStart(2, "0")}`;
      }

      // Start timer and hide status
      function startCrawlTimer() {
        const timer = document.getElementById("crawl-timer");
        const status = document.getElementById("crawl-status");

        crawlStartTime = Date.now();
        timer.classList.add("show");
        status.classList.remove("show");

        // Update timer every 10ms for smooth display
        timerInterval = setInterval(() => {
          const elapsed = Date.now() - crawlStartTime;
          timer.textContent = formatTime(elapsed);
        }, 10);
      }

      // Stop timer
      function stopCrawlTimer() {
        const timer = document.getElementById("crawl-timer");

        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        timer.classList.remove("show");
        crawlStartTime = null;
      }

      // Show crawl status
      function showCrawlStatus(message, isSuccess = false) {
        const status = document.getElementById("crawl-status");
        status.textContent = message;
        status.style.color = isSuccess ? "#ffd700" : "#ff6b6b"; // Yellow for success, red for failure
        status.classList.add("show");

        // Auto-hide status after 8 seconds for success, 5 seconds for failure
        setTimeout(
          () => {
            status.classList.remove("show");
          },
          isSuccess ? 8000 : 5000
        );
      }

      // Show success status based on exit reason
      async function showSuccessStatus() {
        try {
          const response = await fetch(`${API_BASE}/crawl/summary`);
          if (response.ok) {
            const summary = await response.json();
            const exitReason = summary.exit_reason || "Unknown";

            // Map exit reasons to user-friendly messages
            let successMessage = "Success";
            if (
              exitReason.toLowerCase().includes("profile") &&
              exitReason.toLowerCase().includes("threshold")
            ) {
              successMessage = "Success - Profile limit reached";
            } else if (
              exitReason.toLowerCase().includes("runtime") &&
              exitReason.toLowerCase().includes("threshold")
            ) {
              successMessage = "Success - Time limit reached";
            } else if (
              exitReason.toLowerCase().includes("queue") &&
              exitReason.toLowerCase().includes("empty")
            ) {
              successMessage = "Success - Queue completed";
            } else if (exitReason !== "Unknown") {
              successMessage = `Success - ${exitReason}`;
            } else {
              successMessage = "Success - Completed";
            }

            showCrawlStatus(successMessage, true);
          } else {
            // If we can't get summary, still show generic success
            showCrawlStatus("Success - Completed", true);
          }
        } catch (error) {
          console.error("Failed to fetch success status:", error);
          // If there's an error getting the summary, still show generic success
          showCrawlStatus("Success - Completed", true);
        }
      }

      // Crawl functionality
      async function startCrawl() {
        const urlInput = document.getElementById("url-input");
        const urls = urlInput.value.split("\n").filter((url) => url.trim());

        if (urls.length === 0) {
          alert("Please enter at least one URL");
          return;
        }

        // Start timer when crawl starts
        startCrawlTimer();

        try {
          const response = await fetch(`${API_BASE}/crawl`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ urls }),
          });

          if (response.ok) {
            // Start polling for status
            pollCrawlStatus();
          } else {
            // Handle failed response
            stopCrawlTimer();
            showCrawlStatus("Crawl Failed");
          }
        } catch (error) {
          console.error("Crawl failed:", error);
          stopCrawlTimer();
          showCrawlStatus("Crawl Failed");
        }
      }

      // Add event listener for Enter key on URL input
      document
        .getElementById("url-input")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault(); // Prevent default new line behavior
            startCrawl();
          }
        });

      // Poll crawl status
      async function pollCrawlStatus() {
        const interval = setInterval(async () => {
          try {
            const response = await fetch(`${API_BASE}/crawl/status`);
            const status = await response.json();

            if (!status.active) {
              clearInterval(interval);

              // Stop timer when crawl completes
              stopCrawlTimer();

              // Fetch and display crawl summary, then show success status
              await displayCrawlSummary();
              await showSuccessStatus();

              // Refresh the current tab
              loadCurrentTab();
            }
          } catch (error) {
            console.error("Status poll failed:", error);
            clearInterval(interval);
            stopCrawlTimer();
            showCrawlStatus("Crawl Failed");
          }
        }, 2000); // Poll every 2 seconds
      }

      // Display crawl summary
      async function displayCrawlSummary() {
        try {
          const response = await fetch(`${API_BASE}/crawl/summary`);
          if (response.ok) {
            const summary = await response.json();

            // Update summary values
            document.getElementById("new-flagged-comments").textContent =
              summary.new_flagged_comments || 0;
            document.getElementById("unique-villains").textContent =
              summary.unique_villains || 0;
            document.getElementById("new-villains").textContent =
              summary.new_villains || 0;
            document.getElementById("exit-reason").textContent =
              summary.exit_reason || "Unknown";
          } else {
            console.log(
              "Crawl summary endpoint not available, showing default summary"
            );
            // Show default summary if endpoint doesn't exist yet
            document.getElementById("new-flagged-comments").textContent = "N/A";
            document.getElementById("unique-villains").textContent = "N/A";
            document.getElementById("new-villains").textContent = "N/A";
            document.getElementById("exit-reason").textContent =
              "Crawl completed";
          }

          // Show the crawl output section with fade-in
          const crawlOutput = document.getElementById("crawl-output");
          crawlOutput.classList.add("show");

          // Auto-hide after 15 seconds
          setTimeout(() => {
            crawlOutput.classList.remove("show");
          }, 15000);
        } catch (error) {
          console.error("Failed to fetch crawl summary:", error);
          // Still show summary with placeholder data
          document.getElementById("new-flagged-comments").textContent = "N/A";
          document.getElementById("unique-villains").textContent = "N/A";
          document.getElementById("new-villains").textContent = "N/A";
          document.getElementById("exit-reason").textContent =
            "Crawl completed";
          const crawlOutput = document.getElementById("crawl-output");
          crawlOutput.classList.add("show");

          setTimeout(() => {
            crawlOutput.classList.remove("show");
          }, 15000);
        }
      }

      // Load data for current tab
      async function loadCurrentTab() {
        const activeTab = document.querySelector(".tab.active");
        if (!activeTab) {
          console.error("No active tab found");
          return;
        }
        const tabName = activeTab.getAttribute("data-tab");

        switch (tabName) {
          case "flagged-comments":
            await loadFlaggedComments();
            break;
          case "villains":
            await loadVillains();
            break;
          case "reported-profiles":
            await loadReportedProfiles();
            break;
          case "further-monitoring":
            await loadFurtherMonitoring();
            break;
          case "unprocessed-profiles":
            await loadUnprocessedProfiles();
            break;
        }
      }

      // Load flagged comments
      async function loadFlaggedComments() {
        const steamidSearchInput = document.querySelector(
          "#flagged-comments .steamid-search"
        );
        const commentSearchInput = document.querySelector(
          "#flagged-comments .comment-search"
        );
        const timeFilterSelect = document.querySelector("#time-filter-select");
        const sortSelect = document.querySelector(
          "#flagged-comments #sort-select"
        );

        const steamidSearch = steamidSearchInput
          ? steamidSearchInput.value
          : "";
        const commentSearch = commentSearchInput
          ? commentSearchInput.value
          : "";
        const combinedSearch = (steamidSearch + " " + commentSearch).trim();

        const params = new URLSearchParams({
          search: combinedSearch,
          time_filter: getTimeFilterValue(timeFilterSelect.value),
          sort: sortSelect ? sortSelect.value : "newest",
        });

        try {
          const response = await fetch(
            `${API_BASE}/flagged-comments?${params}`
          );
          const data = await response.json();

          displayFlaggedComments(data);
        } catch (error) {
          console.error("Failed to load comments:", error);
        }
      }

      // Convert dropdown value to API parameter
      function getTimeFilterValue(dropdownValue) {
        const mapping = {
          "All Time": "all",
          "Past 1 Hour": "hour",
          "Past 24 Hours": "24hours",
          "Past 7 Days": "7days",
        };
        return mapping[dropdownValue] || "all";
      }

      // Display flagged comments in table
      function displayFlaggedComments(comments) {
        const container = document.querySelector(
          "#flagged-comments .results-table"
        );

        // Keep header
        const header = container.querySelector(".table-header");
        container.innerHTML = "";
        container.appendChild(header);

        if (comments.length === 0) {
          container.innerHTML += `
                    <div class="empty-state">
                        <h3>No flagged comments found</h3>
                        <p>Try adjusting your search criteria</p>
                    </div>
                `;
          return;
        }

        // Sort comments client-side based on selected option
        const sortSelect = document.querySelector("#sort-select");
        const sortOption = sortSelect ? sortSelect.value : "newest";

        const sortedComments = [...comments].sort((a, b) => {
          const dateA = new Date(a.comment_date);
          const dateB = new Date(b.comment_date);

          if (sortOption === "oldest") {
            return dateA - dateB; // oldest first
          } else {
            return dateB - dateA; // newest first (default)
          }
        });

        sortedComments.forEach((comment) => {
          const row = document.createElement("div");
          row.className = "table-row flagged-comments-row";

          // Create avatar HTML
          const avatarHtml =
            comment.avatar_data && comment.avatar_data.avatarfull
              ? `<img src="${comment.avatar_data.avatarfull}" alt="Avatar" class="steam-avatar" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
               <div class="steam-avatar-placeholder" style="display:none;">?</div>`
              : `<div class="steam-avatar-placeholder">?</div>`;

          row.innerHTML = `
                    <div class="avatar-cell">${avatarHtml}</div>
                    <div class="steam-id" data-steamid="${
                      comment.commenter_steamid
                    }">${
            comment.commenter_steamid
          }<br><small style="color: #87ceeb;">${
            comment.commenter_alias || "No alias"
          }</small></div>
                    <div class="comment-text">${comment.comment_text}</div>
                    <div class="timestamp">${formatDate(
                      comment.comment_date
                    )}</div>
                    <div class="timestamp">${formatDate(
                      comment.comment_scraped
                    )}</div>
                    <div class="actions">
                                                <button class="action-button monitor-button"
                                data-steamid="${comment.commenter_steamid}"
                                data-alias="${comment.commenter_alias}"
                                title="Add to monitoring">
                            <svg class="icon eye-closed" viewBox="0 0 24 24">
                                <path d="M12 14c1.66 0 3-1.34 3-3 0-1.66-1.34-3-3-3s-3 1.34-3 3c0 1.66 1.34 3 3 3z"/>
                                <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M1 1l22 22" stroke="currentColor" stroke-width="2"/>
                            </svg>
                            <svg class="icon eye-open" viewBox="0 0 24 24">
                                <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                            </svg>
                        </button>
                        <button class="action-button edit-button"
                                data-steamid="${comment.commenter_steamid}"
                                data-alias="${comment.commenter_alias}"
                                data-profileid=""
                                data-notes=""
                                title="Edit user notes">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                        </button>
                        <button class="action-button report-button" 
                                data-steamid="${comment.commenter_steamid}"
                                data-alias="${comment.commenter_alias}"
                                data-commentid="${comment.id}"
                                title="Report">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                            </svg>
                        </button>
                    </div>
                `;
          container.appendChild(row);
        });

        // Re-attach event listeners
        attachActionListeners();
        attachSteamIdClickHandlers();
      }

      // Attach event listeners to action buttons
      function attachActionListeners() {
        // Report buttons
        document.querySelectorAll(".report-button").forEach((button) => {
          const row = button.closest(".table-row");

          button.addEventListener("mouseenter", () => {
            row.classList.add("hover-report");
          });

          button.addEventListener("mouseleave", () => {
            row.classList.remove("hover-report");
          });

          button.addEventListener("click", async (e) => {
            e.stopPropagation();
            const steamId = button.dataset.steamid;
            const alias = button.dataset.alias;
            const commentId = button.dataset.commentid;

            try {
              const response = await fetch(`${API_BASE}/report`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  steam_id: steamId,
                  alias: alias,
                  comment_id: commentId,
                }),
              });

              if (response.ok) {
                const result = await response.json();
                if (result.duplicate) {
                  if (
                    confirm(
                      result.message + " Would you like to add it anyways?"
                    )
                  ) {
                    // Make another request with force flag
                    const forceResponse = await fetch(`${API_BASE}/report`, {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify({
                        steam_id: steamId,
                        alias: alias,
                        comment_id: commentId,
                        force: true,
                      }),
                    });
                    if (forceResponse.ok) {
                      const forceResult = await forceResponse.json();
                      // Show appropriate message based on whether screenshot is being captured
                      if (
                        commentId &&
                        forceResult.message.includes(
                          "Screenshot capture in progress"
                        )
                      ) {
                        showToast(
                          "Profile reported successfully! Screenshot capture in progress - check ~/Downloads/steam_screenshots/",
                          "success"
                        );
                      } else {
                        showToast("Profile reported successfully", "success");
                      }
                      loadCurrentTab();
                    }
                  }
                } else {
                  // Show appropriate message based on whether screenshot is being captured
                  if (
                    commentId &&
                    result.message.includes("Screenshot capture in progress")
                  ) {
                    showToast(
                      "Profile reported successfully! Screenshot capture in progress - check ~/Downloads/steam_screenshots/",
                      "success"
                    );
                  } else {
                    showToast(
                      result.message || "Profile reported successfully",
                      "success"
                    );
                  }
                  loadCurrentTab();
                }
              }
            } catch (error) {
              console.error("Report failed:", error);
            }
          });
        });

        // Monitor buttons
        document.querySelectorAll(".monitor-button").forEach((button) => {
          const row = button.closest(".table-row");

          button.addEventListener("mouseenter", () => {
            row.classList.add("hover-monitor");
          });

          button.addEventListener("mouseleave", () => {
            row.classList.remove("hover-monitor");
          });

          button.addEventListener("click", async (e) => {
            e.stopPropagation();
            const steamId = button.dataset.steamid;
            const alias = button.dataset.alias;

            try {
              const response = await fetch(`${API_BASE}/monitor`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  steam_id: steamId,
                  alias: alias,
                }),
              });

              if (response.ok) {
                alert("Added to monitoring");
              }
            } catch (error) {
              console.error("Monitor failed:", error);
            }
          });
        });

        // Confirm report buttons
        document.querySelectorAll(".confirm-button").forEach((button) => {
          const row = button.closest(".table-row");

          button.addEventListener("mouseenter", () => {
            row.classList.add("hover-confirm");
          });

          button.addEventListener("mouseleave", () => {
            row.classList.remove("hover-confirm");
          });

          button.addEventListener("click", async (e) => {
            e.stopPropagation();
            const steamId = button.dataset.steamid;
            const alias = button.dataset.alias;
            const profileId = button.dataset.profileid;

            try {
              const response = await fetch(`${API_BASE}/confirm-report`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  steam_id: steamId,
                  alias: alias,
                  profile_id: profileId,
                  submitted_date: new Date().toISOString(),
                }),
              });

              if (response.ok) {
                alert("Report confirmed successfully");
                loadCurrentTab(); // Refresh the data
              }
            } catch (error) {
              console.error("Confirm report failed:", error);
            }
          });
        });

        // Remove from monitoring buttons
        document
          .querySelectorAll(".table-row .remove-button")
          .forEach((button) => {
            const row = button.closest(".table-row");

            button.addEventListener("mouseenter", () => {
              row.classList.add("hover-monitor");
            });

            button.addEventListener("mouseleave", () => {
              row.classList.remove("hover-monitor");
            });

            button.addEventListener("click", async (e) => {
              e.stopPropagation();
              const steamId = button.dataset.steamid;
              const alias = button.dataset.alias;
              const profileId = button.dataset.profileid;

              try {
                const response = await fetch(`${API_BASE}/remove-monitoring`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    steam_id: steamId,
                    alias: alias,
                    profile_id: profileId,
                  }),
                });

                if (response.ok) {
                  alert("Removed from monitoring");
                  loadCurrentTab(); // Refresh the data
                }
              } catch (error) {
                console.error("Remove from monitoring failed:", error);
              }
            });
          });

        // Edit user notes buttons
        document.querySelectorAll(".edit-button").forEach((button) => {
          const row = button.closest(".table-row");

          button.addEventListener("mouseenter", () => {
            row.classList.add("hover-edit");
          });

          button.addEventListener("mouseleave", () => {
            row.classList.remove("hover-edit");
          });

          button.addEventListener("click", async (e) => {
            e.stopPropagation();
            const steamId = button.dataset.steamid;
            const alias = button.dataset.alias;
            const profileId = button.dataset.profileid;
            const currentNotes = button.dataset.notes;

            // Open modal for multi-line notes editing
            openUserNotesModal(steamId, alias, profileId, currentNotes);
          });
        });
      }

      // Attach click handlers to Steam ID elements
      function attachSteamIdClickHandlers() {
        document.querySelectorAll(".steam-id").forEach((element) => {
          element.addEventListener("click", (e) => {
            e.stopPropagation();
            const steamId = element.dataset.steamid;
            if (steamId) {
              // Construct Steam profile URL
              let profileUrl;
              if (steamId.startsWith("765611") && steamId.length === 17) {
                // This is a SteamID64 (17 digits starting with 765611)
                profileUrl = `https://steamcommunity.com/profiles/${steamId}`;
              } else {
                // Assume it's a custom URL/vanity name
                profileUrl = `https://steamcommunity.com/id/${steamId}`;
              }
              window.open(profileUrl, "_blank");
            }
          });
        });
      }

      // Format date helper - standard formatting for most timestamps
      function formatDate(dateString) {
        const date = new Date(dateString);
        console.log(
          "formatDate input:",
          dateString,
          "parsed date:",
          date,
          "timezone offset:",
          date.getTimezoneOffset()
        );

        const dateStr = date.toLocaleDateString("en-US");
        const timeStr = date.toLocaleTimeString("en-US", {
          hour: "numeric",
          minute: "2-digit",
          hour12: true,
        });
        console.log("formatted output:", dateStr, timeStr);
        return `<div>${dateStr}</div><div>${timeStr}</div>`;
      }

      // Format date helper for submitted_date - needs 4 hour adjustment
      function formatSubmittedDate(dateString) {
        const date = new Date(dateString);

        // Adjust the date to compensate for the 4-hour difference
        // Subtract 4 hours (4 * 60 * 60 * 1000 = 14400000 ms) to fix the ahead time
        const adjustedDate = new Date(date.getTime() - 4 * 60 * 60 * 1000);

        console.log(
          "formatSubmittedDate input:",
          dateString,
          "original date:",
          date,
          "adjusted date:",
          adjustedDate
        );

        const dateStr = adjustedDate.toLocaleDateString("en-US");
        const timeStr = adjustedDate.toLocaleTimeString("en-US", {
          hour: "numeric",
          minute: "2-digit",
          hour12: true,
        });
        return `<div>${dateStr}</div><div>${timeStr}</div>`;
      }

      // Sort dropdown change handler
      document.querySelector("#sort-select").addEventListener("change", () => {
        if (
          document.querySelector(".tab.active").getAttribute("data-tab") ===
          "flagged-comments"
        ) {
          loadFlaggedComments();
        }
      });

      // Time filter dropdown change handlers
      document
        .querySelector("#time-filter-select")
        .addEventListener("change", () => {
          loadFlaggedComments();
        });

      document
        .querySelector("#villains-sort-select")
        .addEventListener("change", () => {
          loadVillains();
        });

      document
        .querySelector("#villains-time-filter")
        .addEventListener("change", () => {
          loadVillains();
        });

      document
        .querySelector("#reported-status-filter")
        .addEventListener("change", () => {
          loadReportedProfiles();
        });

      document
        .querySelector("#reported-time-filter")
        .addEventListener("change", () => {
          loadReportedProfiles();
        });

      document
        .querySelector("#monitoring-time-filter")
        .addEventListener("change", () => {
          loadFurtherMonitoring();
        });

      document
        .querySelector("#unprocessed-time-filter")
        .addEventListener("change", () => {
          loadUnprocessedProfiles();
        });

      // Load villains
      async function loadVillains() {
        const searchInput = document.querySelector("#villains-search-input");
        const sortSelect = document.querySelector("#villains-sort-select");
        const timeFilterSelect = document.querySelector(
          "#villains-time-filter"
        );

        const params = new URLSearchParams({
          search: searchInput ? searchInput.value : "",
          sort: sortSelect ? sortSelect.value : "newest",
          time_filter: timeFilterSelect
            ? getTimeFilterValue(timeFilterSelect.value)
            : "all",
        });

        try {
          const response = await fetch(`${API_BASE}/villains?${params}`);
          const data = await response.json();

          displayVillains(data);
        } catch (error) {
          console.error("Failed to load villains:", error);
        }
      }

      // Display villains in table
      function displayVillains(villains) {
        const container = document.querySelector("#villains .results-table");

        // Keep header
        const header = container.querySelector(".table-header");
        container.innerHTML = "";
        container.appendChild(header);

        if (villains.length === 0) {
          container.innerHTML += `
                    <div class="empty-state">
                        <h3>No villains found</h3>
                        <p>Try adjusting your search criteria or run a crawl to detect users posting hate speech</p>
                    </div>
                `;
          return;
        }

        // Sort villains client-side based on selected option
        const sortSelect = document.querySelector("#villains-sort-select");
        const sortOption = sortSelect ? sortSelect.value : "newest";

        const sortedVillains = [...villains].sort((a, b) => {
          const dateA = a.first_seen ? new Date(a.first_seen) : new Date(0);
          const dateB = b.first_seen ? new Date(b.first_seen) : new Date(0);

          if (sortOption === "oldest") {
            return dateA - dateB; // oldest first
          } else {
            return dateB - dateA; // newest first (default)
          }
        });

        sortedVillains.forEach((villain) => {
          const row = document.createElement("div");
          row.className = "table-row villains-row";

          // Create avatar HTML
          const avatarHtml =
            villain.avatar_data && villain.avatar_data.avatarfull
              ? `<img src="${villain.avatar_data.avatarfull}" alt="Avatar" class="steam-avatar" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
               <div class="steam-avatar-placeholder" style="display:none;">?</div>`
              : `<div class="steam-avatar-placeholder">?</div>`;

          row.innerHTML = `
                    <div class="avatar-cell">${avatarHtml}</div>
                    <div class="steam-id" data-steamid="${villain.steam_id}">${
            villain.steam_id
          }<br><small style="color: #87ceeb;">${
            villain.aliases || "No aliases"
          }</small></div>
                    <div class="user-notes">${
                      villain.user_notes || "No notes"
                    }</div>
                    <div class="timestamp">${
                      villain.first_seen
                        ? formatDate(villain.first_seen)
                        : "<div>Unknown</div><div></div>"
                    }</div>
                    <div class="actions">
                                                <button class="action-button monitor-button"
                                data-steamid="${villain.steam_id}"
                                data-alias="${villain.aliases}"
                                title="Add to monitoring">
                            <svg class="icon eye-closed" viewBox="0 0 24 24">
                                <path d="M12 14c1.66 0 3-1.34 3-3 0-1.66-1.34-3-3-3s-3 1.34-3 3c0 1.66 1.34 3 3 3z"/>
                                <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M1 1l22 22" stroke="currentColor" stroke-width="2"/>
                            </svg>
                            <svg class="icon eye-open" viewBox="0 0 24 24">
                                <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                            </svg>
                        </button>
                        <button class="action-button edit-button"
                                data-steamid="${villain.steam_id}"
                                data-alias="${villain.aliases}"
                                data-profileid="${villain.id || ""}"
                                data-notes="${villain.user_notes || ""}"
                                title="Edit user notes">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                        </button>
                        <button class="action-button report-button" 
                                data-steamid="${villain.steam_id}"
                                data-alias="${villain.aliases}"
                                title="Report">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                            </svg>
                        </button>
                    </div>
                `;
          container.appendChild(row);
        });

        // Re-attach event listeners
        attachActionListeners();
        attachSteamIdClickHandlers();
      }

      // Load reported profiles
      async function loadReportedProfiles() {
        const searchInput = document.querySelector(
          "#reported-profiles .search-input"
        );
        const statusFilterSelect = document.querySelector(
          "#reported-status-filter"
        );
        const timeFilterSelect = document.querySelector(
          "#reported-time-filter"
        );

        const params = new URLSearchParams({
          search: searchInput ? searchInput.value : "",
          status_filter: statusFilterSelect
            ? getStatusFilterValue(statusFilterSelect.value)
            : "all",
          time_filter: timeFilterSelect
            ? getTimeFilterValue(timeFilterSelect.value)
            : "all",
        });

        try {
          const response = await fetch(
            `${API_BASE}/reported-profiles?${params}`
          );
          const data = await response.json();

          displayReportedProfiles(data);
        } catch (error) {
          console.error("Failed to load reported profiles:", error);
        }
      }

      // Load monitoring
      async function loadFurtherMonitoring() {
        const searchInput = document.querySelector(
          "#further-monitoring .search-input"
        );
        const timeFilterSelect = document.querySelector(
          "#monitoring-time-filter"
        );

        const params = new URLSearchParams({
          search: searchInput ? searchInput.value : "",
          time_filter: timeFilterSelect
            ? getTimeFilterValue(timeFilterSelect.value)
            : "all",
        });

        try {
          const response = await fetch(
            `${API_BASE}/further-monitoring?${params}`
          );
          const data = await response.json();

          displayFurtherMonitoring(data);
        } catch (error) {
          console.error("Failed to load monitoring:", error);
        }
      }

      // Load unprocessed profiles
      async function loadUnprocessedProfiles() {
        const searchInput = document.querySelector(
          "#unprocessed-profiles .search-input"
        );
        const timeFilterSelect = document.querySelector(
          "#unprocessed-time-filter"
        );

        const params = new URLSearchParams({
          search: searchInput ? searchInput.value : "",
          time_filter: timeFilterSelect
            ? getTimeFilterValue(timeFilterSelect.value)
            : "all",
        });

        try {
          const response = await fetch(
            `${API_BASE}/unprocessed-profiles?${params}`
          );
          const data = await response.json();

          displayUnprocessedProfiles(data);
        } catch (error) {
          console.error("Failed to load unprocessed profiles:", error);
        }
      }

      // Helper function for status filter mapping
      function getStatusFilterValue(dropdownValue) {
        const mapping = {
          "All Statuses": "all",
          "Pending Review": "pending review",
          Reported: "reported",
        };
        return mapping[dropdownValue] || "all";
      }

      // Display functions for the remaining tabs
      function displayReportedProfiles(profiles) {
        const container = document.querySelector(
          "#reported-profiles .results-table"
        );

        // Keep header
        const header = container.querySelector(".table-header");
        container.innerHTML = "";
        container.appendChild(header);

        if (profiles.length === 0) {
          container.innerHTML += `
                    <div class="empty-state">
                        <h3>No reported profiles</h3>
                        <p>Select comments from the Flagged Comments tab to report profiles</p>
                    </div>
                `;
          return;
        }

        profiles.forEach((profile) => {
          const row = document.createElement("div");
          row.className = "table-row reported-profiles-row";

          // Create avatar HTML
          const avatarHtml =
            profile.avatar_data && profile.avatar_data.avatarfull
              ? `<img src="${profile.avatar_data.avatarfull}" alt="Avatar" class="steam-avatar" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
               <div class="steam-avatar-placeholder" style="display:none;">?</div>`
              : `<div class="steam-avatar-placeholder">?</div>`;

          row.innerHTML = `
                    <div class="avatar-cell">${avatarHtml}</div>
                    <div class="steam-id" data-steamid="${profile.steam_id}">${
            profile.steam_id
          }<br><small style="color: #87ceeb;">${
            profile.alias || "No alias"
          }</small></div>
                    <div class="comment-text">${
                      profile.comment_text || "No comment text available"
                    }</div>
                    <div class="status-badge ${profile.status.replace(
                      " ",
                      "-"
                    )}">${
            profile.status === "reported" && profile.submitted_date
              ? `<span style="color: #00cc00;">REPORTED</span><br><small style="font-size: 11px; color: #999;">${formatSubmittedDate(
                  profile.submitted_date
                )
                  .replace(/<div>/g, "")
                  .replace(/<\/div>/g, " ")
                  .trim()}</small>`
              : profile.status === "pending review"
              ? `<span style="color: #cc0000;">PENDING REVIEW</span>`
              : profile.status
          }</div>
                    <div class="timestamp">${formatDate(
                      profile.reported_date
                    )}</div>
                    <div class="actions">
                        <button class="action-button monitor-button"
                                data-steamid="${profile.steam_id}"
                                data-alias="${profile.alias}"
                                title="Add to monitoring">
                            <svg class="icon eye-closed" viewBox="0 0 24 24">
                                <path d="M12 14c1.66 0 3-1.34 3-3 0-1.66-1.34-3-3-3s-3 1.34-3 3c0 1.66 1.34 3 3 3z"/>
                                <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z" fill="none" stroke="currentColor" stroke-width="2"/>
                                <path d="M1 1l22 22" stroke="currentColor" stroke-width="2"/>
                            </svg>
                            <svg class="icon eye-open" viewBox="0 0 24 24">
                                <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                            </svg>
                        </button>
                        ${
                          profile.status === "pending review"
                            ? `
                        <button class="action-button confirm-button"
                                data-steamid="${profile.steam_id}"
                                data-alias="${profile.alias}"
                                data-profileid="${profile.id || ""}"
                                title="Confirm report">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                            </svg>
                        </button>
                        `
                            : ""
                        }
                    </div>
                `;
          container.appendChild(row);
        });

        attachActionListeners();
        attachSteamIdClickHandlers();
      }

      function displayFurtherMonitoring(profiles) {
        const container = document.querySelector(
          "#further-monitoring .results-table"
        );

        // Clear and rebuild container
        container.innerHTML = `
          <div class="empty-state">
              <h3>No profiles being monitored</h3>
              <p>Add profiles from Flagged Comments or Villains tabs for continued monitoring</p>
          </div>
        `;

        if (profiles.length > 0) {
          container.innerHTML = `
            <div class="table-header" style="grid-template-columns: 40px 250px 1fr 120px 130px;">
              <div></div>
              <div>
                <div>Steam ID</div>
                <div>& Alias</div>
              </div>
              <div class="user-notes-header">
                <div>User</div>
                <div>Notes</div>
              </div>
              <div>
                <div>Date</div>
                <div>Added</div>
              </div>
              <div></div>
            </div>
          `;

          profiles.forEach((profile) => {
            const row = document.createElement("div");
            row.className = "table-row";
            row.style.gridTemplateColumns = "40px 250px 1fr 120px 130px";

            // Create avatar HTML
            const avatarHtml =
              profile.avatar_data && profile.avatar_data.avatarfull
                ? `<img src="${profile.avatar_data.avatarfull}" alt="Avatar" class="steam-avatar" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                 <div class="steam-avatar-placeholder" style="display:none;">?</div>`
                : `<div class="steam-avatar-placeholder">?</div>`;

            row.innerHTML = `
                      <div class="avatar-cell">${avatarHtml}</div>
                      <div class="steam-id" data-steamid="${
                        profile.steam_id
                      }">${
              profile.steam_id
            }<br><small style="color: #87ceeb;">${
              profile.alias || "No alias"
            }</small></div>
                      <div class="user-notes">${
                        profile.user_notes || "No notes"
                      }</div>
                      <div class="timestamp">${formatDate(
                        profile.added_date
                      )}</div>
                      <div class="actions">
                          <button class="action-button edit-button"
                                  data-steamid="${profile.steam_id}"
                                  data-alias="${profile.alias}"
                                  data-profileid="${profile.id || ""}"
                                  data-notes="${profile.user_notes || ""}"
                                  title="Edit user notes">
                              <svg class="icon" viewBox="0 0 24 24">
                                  <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                              </svg>
                          </button>
                          <button class="action-button remove-button"
                                  data-steamid="${profile.steam_id}"
                                  data-alias="${profile.alias}"
                                  data-profileid="${profile.id || ""}"
                                  title="Remove from monitoring">
                              <svg class="icon" viewBox="0 0 24 24">
                                  <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                              </svg>
                          </button>
                      </div>
                  `;
            container.appendChild(row);
          });

          attachActionListeners();
          attachSteamIdClickHandlers();
        }
      }

      function displayUnprocessedProfiles(profiles) {
        const container = document.querySelector(
          "#unprocessed-profiles .results-table"
        );

        // Clear and rebuild container
        container.innerHTML = `
          <div class="empty-state">
              <h3>No unprocessed profiles</h3>
              <p>Profiles that couldn't be processed due to system limits will appear here</p>
          </div>
        `;

        if (profiles.length > 0) {
          container.innerHTML = `
            <div class="table-header" style="grid-template-columns: 250px 1fr 120px 120px;">
              <div>
                <div>Steam ID</div>
                <div>& Alias</div>
              </div>
              <div>
                <div>Path</div>
                <div>Discovered</div>
              </div>
              <div>
                <div>Date</div>
                <div>Added</div>
              </div>
              <div> </div>
            </div>
          `;

          profiles.forEach((profile) => {
            const row = document.createElement("div");
            row.className = "table-row";
            row.style.gridTemplateColumns = "250px 1fr 120px 120px";
            row.innerHTML = `
                      <div class="steam-id" data-steamid="${
                        profile.steam_id
                      }">${
              profile.steam_id
            }<br><small style="color: #87ceeb;">${
              profile.known_aliases || "No aliases"
            }</small></div>
                      <div class="comment-text">${profile.friend_path}</div>
                      <div class="timestamp">${
                        profile.added_timestamp
                          ? formatDate(profile.added_timestamp)
                          : "<div>Unknown</div><div></div>"
                      }</div>
                      <div class="actions"></div>
                  `;
            container.appendChild(row);
          });

          attachSteamIdClickHandlers();
        }
      }

      // Update user notes in both villains and monitoring tabs
      function updateUserNotesInBothTabs(steamId, newNotes) {
        // Function to update a specific tab
        function updateTabUserNotes(tabSelector) {
          const tab = document.querySelector(tabSelector);
          if (tab) {
            const rows = tab.querySelectorAll(".table-row");
            rows.forEach((row) => {
              const steamIdElement = row.querySelector(".steam-id");
              if (
                steamIdElement &&
                steamIdElement.dataset.steamid === steamId
              ) {
                const userNotesElement = row.querySelector(".user-notes");
                if (userNotesElement) {
                  // Use textContent to preserve line breaks
                  userNotesElement.textContent = newNotes || "No notes";
                }
                // Update the edit button's data-notes attribute
                const editButton = row.querySelector(".edit-button");
                if (editButton) {
                  editButton.dataset.notes = newNotes || "";
                }
              }
            });
          }
        }

        // Update both tabs
        updateTabUserNotes("#villains .results-table");
        updateTabUserNotes("#further-monitoring .results-table");

        // If the monitoring tab is currently active but empty, reload it to get fresh data
        const activeTab = document.querySelector(".tab.active");
        if (
          activeTab &&
          activeTab.getAttribute("data-tab") === "further-monitoring"
        ) {
          const monitoringContainer = document.querySelector(
            "#further-monitoring .results-table"
          );
          const emptyState = monitoringContainer.querySelector(".empty-state");
          if (emptyState) {
            // If monitoring tab is active and shows empty state, reload it
            loadFurtherMonitoring();
          }
        }
      }

      // Toast notification function
      function showToast(message, type = "info") {
        // Create toast element
        const toast = document.createElement("div");
        toast.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          padding: 16px 24px;
          border-radius: 8px;
          color: white;
          font-size: 14px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
          max-width: 300px;
        `;

        // Set background color based on type
        const colors = {
          success: "#4caf50",
          error: "#ff4444",
          info: "#2196f3",
        };
        toast.style.backgroundColor = colors[type] || colors.info;

        toast.textContent = message;
        document.body.appendChild(toast);

        // Fade in
        setTimeout(() => {
          toast.style.opacity = "1";
        }, 10);

        // Remove after 3 seconds
        setTimeout(() => {
          toast.style.opacity = "0";
          setTimeout(() => {
            document.body.removeChild(toast);
          }, 300);
        }, 3000);
      }

      // Inline Search Terms Functions
      let allInlineHateTerms = [];

      async function loadInlineHateTerms() {
        try {
          const response = await fetch(`${API_BASE}/hate-terms`);
          const data = await response.json();
          if (response.ok) {
            allInlineHateTerms = data.terms || [];
            displayInlineHateTerms(allInlineHateTerms);
            updateInlineHateTermsCount(allInlineHateTerms.length);
          } else {
            console.error("Failed to load search terms:", data.error);
            document.getElementById("inline-hate-terms-results").innerHTML =
              '<p style="text-align: center; color: #ff4444; padding: 20px;">Failed to load search terms</p>';
          }
        } catch (error) {
          console.error("Error loading search terms:", error);
          document.getElementById("inline-hate-terms-results").innerHTML =
            '<p style="text-align: center; color: #ff4444; padding: 20px;">Error loading search terms</p>';
        }
      }

      function displayInlineHateTerms(terms) {
        const resultsDiv = document.getElementById("inline-hate-terms-results");
        if (terms.length === 0) {
          resultsDiv.innerHTML =
            '<p style="text-align: center; color: #666; padding: 20px;">No search terms configured</p>';
          return;
        }

        const sortedTerms = [...terms].sort((a, b) =>
          a.toLowerCase().localeCompare(b.toLowerCase())
        );

        const html = sortedTerms
          .filter((term) => term.length < 100) // Filter out extremely long terms
          .map((term) => {
            const escapedTerm = term.replace(/[<>&"']/g, function (m) {
              return {
                "<": "&lt;",
                ">": "&gt;",
                "&": "&amp;",
                '"': "&quot;",
                "'": "&#39;",
              }[m];
            });
            const escapedTermForJS = term.replace(/['"\\]/g, "\\$&");
            return `
          <div class="search-term-item" style="display: flex; justify-content: space-between; align-items: center; padding: 4px 6px;">
            <span class="search-term-text" style="color: #e0e0e0; font-size: 13px;">${escapedTerm}</span>
            <button class="action-button remove-button" 
                    onclick="deleteInlineHateTerm('${escapedTermForJS}')"
                    title="Remove search term">
              <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
              </svg>
            </button>
          </div>`;
          })
          .join("");
        resultsDiv.innerHTML = html;
      }

      function filterInlineHateTerms() {
        const searchTerm = document
          .getElementById("inline-hate-terms-search")
          .value.toLowerCase();
        const filteredTerms = allInlineHateTerms.filter((term) =>
          term.toLowerCase().includes(searchTerm)
        );
        displayInlineHateTerms(filteredTerms);
        updateInlineHateTermsCount(filteredTerms.length);
      }

      function updateInlineHateTermsCount(count) {
        document.getElementById(
          "inline-hate-terms-count"
        ).textContent = `${count} term${count !== 1 ? "s" : ""}`;
      }

      async function addInlineHateTerm() {
        const input = document.getElementById("inline-new-hate-term-input");
        const term = input.value.trim();
        if (!term) {
          showToast("Please enter a term", "error");
          return;
        }
        try {
          const response = await fetch(`${API_BASE}/hate-terms`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ term }),
          });
          const data = await response.json();
          if (response.ok) {
            input.value = "";
            showToast("Search term added successfully", "success");
            await loadInlineHateTerms();
          } else {
            showToast(data.error || "Failed to add search term", "error");
          }
        } catch (error) {
          console.error("Error adding search term:", error);
          showToast("Error adding search term", "error");
        }
      }

      async function deleteInlineHateTerm(term) {
        if (!confirm(`Are you sure you want to delete "${term}"?`)) {
          return;
        }
        try {
          const response = await fetch(
            `${API_BASE}/hate-terms/${encodeURIComponent(term)}`,
            {
              method: "DELETE",
            }
          );
          const data = await response.json();
          if (response.ok) {
            showToast("Search term deleted successfully", "success");
            await loadInlineHateTerms();
          } else {
            showToast(data.error || "Failed to delete search term", "error");
          }
        } catch (error) {
          console.error("Error deleting search term:", error);
          showToast("Error deleting search term", "error");
        }
      }

      // Add event listener for Enter key on inline new term input
      setTimeout(() => {
        const inlineInput = document.getElementById(
          "inline-new-hate-term-input"
        );
        if (inlineInput) {
          inlineInput.addEventListener("keypress", function (e) {
            if (e.key === "Enter") {
              addInlineHateTerm();
            }
          });
        }
      }, 100);

      // Load inline hate terms when page loads
      setTimeout(() => {
        loadInlineHateTerms();
      }, 500);

      // Manual Villain Addition Function
      async function addManualVillain() {
        console.log("addManualVillain() called");

        const steamIdInput = document.getElementById("manual-steam-id-input");

        console.log("Steam ID input element:", steamIdInput);

        if (!steamIdInput) {
          console.error("Could not find steam ID input element");
          showToast("Form error: Could not find input field", "error");
          return;
        }

        const steamId = steamIdInput.value.trim();
        const alias = "";

        console.log(
          "Steam ID input value:",
          `"${steamId}"`,
          "Length:",
          steamId.length
        );

        if (!steamId || steamId.length === 0) {
          showToast(
            'Please enter a Steam ID or username in the first field (e.g., "SinWulfexe")',
            "error"
          );
          steamIdInput.focus();
          return;
        }

        // Show loading state in input placeholder
        const originalPlaceholder = steamIdInput.placeholder;
        steamIdInput.placeholder = "Adding villain...";
        steamIdInput.disabled = true;

        // Check if it's a username (not a 17-digit SteamID64)
        const isUsername = !/^\d{17}$/.test(steamId);
        console.log("Is username (not SteamID64):", isUsername);

        if (isUsername) {
          showToast(
            `Resolving Steam username "${steamId}" and fetching avatar...`,
            "info"
          );
        } else {
          showToast(`Adding villain and fetching avatar data...`, "info");
        }

        try {
          console.log("Sending request to API...");
          const response = await fetch(`${API_BASE}/add-villain`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              steam_id: steamId,
              alias: alias || steamId,
              user_notes: "Manually added villain",
            }),
          });

          console.log("Response status:", response.status);
          const data = await response.json();
          console.log("Response data:", data);

          if (response.ok) {
            showToast(data.message || "Villain added successfully", "success");
            steamIdInput.value = "";
            // Reload villains tab if it's currently active
            const activeTab = document.querySelector(".tab.active");
            if (
              activeTab &&
              activeTab.getAttribute("data-tab") === "villains"
            ) {
              loadVillains();
            }
          } else {
            showToast(data.error || "Failed to add villain", "error");
          }
        } catch (error) {
          console.error("Error adding manual villain:", error);
          showToast(`Network error: ${error.message}`, "error");
        } finally {
          // Restore input state
          steamIdInput.placeholder = originalPlaceholder;
          steamIdInput.disabled = false;
        }
      }

      // Add event listeners for Enter key on manual villain inputs
      document
        .getElementById("manual-steam-id-input")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            addManualVillain();
          }
        });

      // Initial load
      loadCurrentTab();

      // Attach handlers to any existing Steam IDs (like sample data)
      attachSteamIdClickHandlers();

      // User Notes Modal Functions
      let currentEditingProfile = null;

      function openUserNotesModal(steamId, alias, profileId, currentNotes) {
        currentEditingProfile = { steamId, alias, profileId };
        document.getElementById("userNotesTextarea").value = currentNotes || "";
        document.getElementById("userNotesModal").style.display = "block";

        // Focus on textarea
        setTimeout(() => {
          document.getElementById("userNotesTextarea").focus();
        }, 100);
      }

      function closeUserNotesModal() {
        document.getElementById("userNotesModal").style.display = "none";
        currentEditingProfile = null;
      }

      async function saveUserNotes() {
        if (!currentEditingProfile) return;

        const newNotes = document.getElementById("userNotesTextarea").value;
        const { steamId, alias, profileId } = currentEditingProfile;

        try {
          const response = await fetch(`${API_BASE}/update-notes`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              steam_id: steamId,
              alias: alias,
              profile_id: profileId,
              user_notes: newNotes,
            }),
          });

          if (response.ok) {
            showToast("User notes updated successfully", "success");
            // Update notes in both villains and monitoring tabs
            updateUserNotesInBothTabs(steamId, newNotes);

            // Also refresh the current tab to ensure data consistency
            const activeTab = document.querySelector(".tab.active");
            const currentTabName = activeTab
              ? activeTab.getAttribute("data-tab")
              : null;

            // Refresh both villains and monitoring tabs if they might contain this user
            if (currentTabName === "villains") {
              loadVillains();
            } else if (currentTabName === "further-monitoring") {
              loadFurtherMonitoring();
            } else {
              // If we're on a different tab, still try to update the data in background
              // This ensures when user switches tabs, they see updated data
              setTimeout(() => {
                loadVillains();
                loadFurtherMonitoring();
              }, 100);
            }

            closeUserNotesModal();
          } else {
            showToast("Failed to update user notes", "error");
          }
        } catch (error) {
          console.error("Update notes failed:", error);
          showToast("Failed to update user notes", "error");
        }
      }

      // Close modal when clicking outside of it
      window.addEventListener("click", function (event) {
        const modal = document.getElementById("userNotesModal");
        if (event.target === modal) {
          closeUserNotesModal();
        }
      });

      // Close modal with Escape key
      document.addEventListener("keydown", function (event) {
        if (event.key === "Escape") {
          closeUserNotesModal();
        }
      });

      // Dynamic Search Functionality - Add event listeners for real-time filtering
      function setupDynamicSearch() {
        // Comments tab search - both steamid and comment search inputs
        const steamidSearchInput = document.querySelector(
          "#flagged-comments .steamid-search"
        );
        const commentSearchInput = document.querySelector(
          "#flagged-comments .comment-search"
        );

        if (steamidSearchInput) {
          steamidSearchInput.addEventListener("input", function () {
            loadFlaggedComments();
          });
        }

        if (commentSearchInput) {
          commentSearchInput.addEventListener("input", function () {
            loadFlaggedComments();
          });
        }

        // Villains tab search
        const villainsSearchInput = document.querySelector(
          "#villains-search-input"
        );
        if (villainsSearchInput) {
          villainsSearchInput.addEventListener("input", function () {
            loadVillains();
          });
        }

        // Reported profiles tab search
        const reportedSearchInput = document.querySelector(
          "#reported-profiles .search-input"
        );
        if (reportedSearchInput) {
          reportedSearchInput.addEventListener("input", function () {
            loadReportedProfiles();
          });
        }

        // Monitoring tab search
        const monitoringSearchInput = document.querySelector(
          "#further-monitoring .search-input"
        );
        if (monitoringSearchInput) {
          monitoringSearchInput.addEventListener("input", function () {
            loadFurtherMonitoring();
          });
        }

        // Unprocessed profiles tab search
        const unprocessedSearchInput = document.querySelector(
          "#unprocessed-profiles .search-input"
        );
        if (unprocessedSearchInput) {
          unprocessedSearchInput.addEventListener("input", function () {
            loadUnprocessedProfiles();
          });
        }
      }

      // Simple initialization
      setTimeout(() => {
        console.log("Basic initialization starting...");
        try {
          setupDynamicSearch();
          console.log("Dynamic search setup complete");
          loadFlaggedComments();
          console.log("Load flagged comments called");
        } catch (error) {
          console.error("Initialization error:", error);
        }
      }, 2000);
    </script>
  </body>
</html>
